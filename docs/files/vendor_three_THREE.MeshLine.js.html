<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>vendor\three\THREE.MeshLine.js - ExplorViz: UI Frontend API</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="ExplorViz: UI Frontend API" src="https://www.explorviz.net/img/favicon.png" style="max-height: 65%;" title="ExplorViz: UI Frontend API">
            ExplorViz: UI Frontend API
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>0.0.1</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Authenticator", "classes/Rendering-Core"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <h3>APIs</h3>
	        <div id="sidebar">
	            <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
	                <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
	                <li><a href="#modules" data-toggle="tab">Modules</a></li>
	            </ul>
	    
	            <div id="api-tabview-filter">
	                <input type="search" placeholder="Type to filter APIs">
	            </div>
	    
	            <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
	                <div class="tab-pane active" id="classes">
	                    <ul id="api-classes" class="nav nav-list">
	                            <li><a href="../classes/Authenticator.html">Authenticator</a></li>
	                            <li><a href="../classes/Rendering-Core.html">Rendering-Core</a></li>
	                    </ul>
	                </div>
	    
	                <div class="tab-pane" id="modules">
	                    <ul id="api-modules" class="nav nav-list">
	                    </ul>
	                </div>
	            </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>vendor\three\THREE.MeshLine.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
;(function() {

&quot;use strict&quot;;

var root = this

var has_require = typeof require !== &#x27;undefined&#x27;

var THREE = root.THREE || has_require &amp;&amp; require(&#x27;three&#x27;)
if( !THREE )
  throw new Error( &#x27;EquirectangularToCubemap requires three.js&#x27; )

function MeshLine() {

  this.positions = [];

  this.previous = [];
  this.next = [];
  this.side = [];
  this.width = [];
  this.indices_array = [];
  this.uvs = [];
  this.counters = [];
  this.geometry = new THREE.BufferGeometry();

  this.widthCallback = null;

}

MeshLine.prototype.setGeometry = function( g, c ) {

  this.widthCallback = c;

  this.positions = [];
  this.counters = [];

  if( g instanceof THREE.Geometry ) {
    for( var j = 0; j &lt; g.vertices.length; j++ ) {
      var v = g.vertices[ j ];
      var c = j/g.vertices.length;
      this.positions.push( v.x, v.y, v.z );
      this.positions.push( v.x, v.y, v.z );
      this.counters.push(c);
      this.counters.push(c);
    }
  }

  if( g instanceof THREE.BufferGeometry ) {
    // read attribute positions ?
  }

  if( g instanceof Float32Array || g instanceof Array ) {
    for( var j = 0; j &lt; g.length; j += 3 ) {
      var c = j/g.length;
      this.positions.push( g[ j ], g[ j + 1 ], g[ j + 2 ] );
      this.positions.push( g[ j ], g[ j + 1 ], g[ j + 2 ] );
      this.counters.push(c);
      this.counters.push(c);
    }
  }

  this.process();

}

MeshLine.prototype.compareV3 = function( a, b ) {

  var aa = a * 6;
  var ab = b * 6;
  return ( this.positions[ aa ] === this.positions[ ab ] ) &amp;&amp; ( this.positions[ aa + 1 ] === this.positions[ ab + 1 ] ) &amp;&amp; ( this.positions[ aa + 2 ] === this.positions[ ab + 2 ] );

}

MeshLine.prototype.copyV3 = function( a ) {

  var aa = a * 6;
  return [ this.positions[ aa ], this.positions[ aa + 1 ], this.positions[ aa + 2 ] ];

}

MeshLine.prototype.process = function() {

  var l = this.positions.length / 6;

  this.previous = [];
  this.next = [];
  this.side = [];
  this.width = [];
  this.indices_array = [];
  this.uvs = [];

  for( var j = 0; j &lt; l; j++ ) {
    this.side.push( 1 );
    this.side.push( -1 );
  }

  var w;
  for( var j = 0; j &lt; l; j++ ) {
    if( this.widthCallback ) w = this.widthCallback( j / ( l -1 ) );
    else w = 1;
    this.width.push( w );
    this.width.push( w );
  }

  for( var j = 0; j &lt; l; j++ ) {
    this.uvs.push( j / ( l - 1 ), 0 );
    this.uvs.push( j / ( l - 1 ), 1 );
  }

  var v;

  if( this.compareV3( 0, l - 1 ) ){
    v = this.copyV3( l - 2 );
  } else {
    v = this.copyV3( 0 );
  }
  this.previous.push( v[ 0 ], v[ 1 ], v[ 2 ] );
  this.previous.push( v[ 0 ], v[ 1 ], v[ 2 ] );
  for( var j = 0; j &lt; l - 1; j++ ) {
    v = this.copyV3( j );
    this.previous.push( v[ 0 ], v[ 1 ], v[ 2 ] );
    this.previous.push( v[ 0 ], v[ 1 ], v[ 2 ] );
  }

  for( var j = 1; j &lt; l; j++ ) {
    v = this.copyV3( j );
    this.next.push( v[ 0 ], v[ 1 ], v[ 2 ] );
    this.next.push( v[ 0 ], v[ 1 ], v[ 2 ] );
  }

  if( this.compareV3( l - 1, 0 ) ){
    v = this.copyV3( 1 );
  } else {
    v = this.copyV3( l - 1 );
  }
  this.next.push( v[ 0 ], v[ 1 ], v[ 2 ] );
  this.next.push( v[ 0 ], v[ 1 ], v[ 2 ] );

  for( var j = 0; j &lt; l - 1; j++ ) {
    var n = j * 2;
    this.indices_array.push( n, n + 1, n + 2 );
    this.indices_array.push( n + 2, n + 1, n + 3 );
  }

  if (!this.attributes) {
    this.attributes = {
      position: new THREE.BufferAttribute( new Float32Array( this.positions ), 3 ),
      previous: new THREE.BufferAttribute( new Float32Array( this.previous ), 3 ),
      next: new THREE.BufferAttribute( new Float32Array( this.next ), 3 ),
      side: new THREE.BufferAttribute( new Float32Array( this.side ), 1 ),
      width: new THREE.BufferAttribute( new Float32Array( this.width ), 1 ),
      uv: new THREE.BufferAttribute( new Float32Array( this.uvs ), 2 ),
      index: new THREE.BufferAttribute( new Uint16Array( this.indices_array ), 1 ),
      counters: new THREE.BufferAttribute( new Float32Array( this.counters ), 1 )
    }
  } else {
    this.attributes.position.copyArray(new Float32Array(this.positions));
    this.attributes.position.needsUpdate = true;
    this.attributes.previous.copyArray(new Float32Array(this.previous));
    this.attributes.previous.needsUpdate = true;
    this.attributes.next.copyArray(new Float32Array(this.next));
    this.attributes.next.needsUpdate = true;
    this.attributes.side.copyArray(new Float32Array(this.side));
    this.attributes.side.needsUpdate = true;
    this.attributes.width.copyArray(new Float32Array(this.width));
    this.attributes.width.needsUpdate = true;
    this.attributes.uv.copyArray(new Float32Array(this.uvs));
    this.attributes.uv.needsUpdate = true;
    this.attributes.index.copyArray(new Uint16Array(this.indices_array));
    this.attributes.index.needsUpdate = true;
    }

  this.geometry.addAttribute( &#x27;position&#x27;, this.attributes.position );
  this.geometry.addAttribute( &#x27;previous&#x27;, this.attributes.previous );
  this.geometry.addAttribute( &#x27;next&#x27;, this.attributes.next );
  this.geometry.addAttribute( &#x27;side&#x27;, this.attributes.side );
  this.geometry.addAttribute( &#x27;width&#x27;, this.attributes.width );
  this.geometry.addAttribute( &#x27;uv&#x27;, this.attributes.uv );
  this.geometry.addAttribute( &#x27;counters&#x27;, this.attributes.counters );

  this.geometry.setIndex( this.attributes.index );

}

function memcpy (src, srcOffset, dst, dstOffset, length) {
  var i

  src = src.subarray || src.slice ? src : src.buffer
  dst = dst.subarray || dst.slice ? dst : dst.buffer

  src = srcOffset ? src.subarray ?
  src.subarray(srcOffset, length &amp;&amp; srcOffset + length) :
  src.slice(srcOffset, length &amp;&amp; srcOffset + length) : src

  if (dst.set) {
    dst.set(src, dstOffset)
  } else {
    for (i=0; i&lt;src.length; i++) {
      dst[i + dstOffset] = src[i]
    }
  }

  return dst
}

/**
 * Fast method to advance the line by one position.  The oldest position is removed.
 * @param position
 */
MeshLine.prototype.advance = function(position) {

  var positions = this.attributes.position.array;
  var previous = this.attributes.previous.array;
  var next = this.attributes.next.array;
  var l = positions.length;

  // PREVIOUS
  memcpy( positions, 0, previous, 0, l );

  // POSITIONS
  memcpy( positions, 6, positions, 0, l - 6 );

  positions[l - 6] = position.x;
  positions[l - 5] = position.y;
  positions[l - 4] = position.z;
  positions[l - 3] = position.x;
  positions[l - 2] = position.y;
  positions[l - 1] = position.z;

    // NEXT
  memcpy( positions, 6, next, 0, l - 6 );

  next[l - 6]  = position.x;
  next[l - 5]  = position.y;
  next[l - 4]  = position.z;
  next[l - 3]  = position.x;
  next[l - 2]  = position.y;
  next[l - 1]  = position.z;

  this.attributes.position.needsUpdate = true;
  this.attributes.previous.needsUpdate = true;
  this.attributes.next.needsUpdate = true;

};

function MeshLineMaterial( parameters ) {

  var vertexShaderSource = [
&#x27;precision highp float;&#x27;,
&#x27;&#x27;,
&#x27;attribute vec3 position;&#x27;,
&#x27;attribute vec3 previous;&#x27;,
&#x27;attribute vec3 next;&#x27;,
&#x27;attribute float side;&#x27;,
&#x27;attribute float width;&#x27;,
&#x27;attribute vec2 uv;&#x27;,
&#x27;attribute float counters;&#x27;,
&#x27;&#x27;,
&#x27;uniform mat4 projectionMatrix;&#x27;,
&#x27;uniform mat4 modelViewMatrix;&#x27;,
&#x27;uniform vec2 resolution;&#x27;,
&#x27;uniform float lineWidth;&#x27;,
&#x27;uniform vec3 color;&#x27;,
&#x27;uniform float opacity;&#x27;,
&#x27;uniform float near;&#x27;,
&#x27;uniform float far;&#x27;,
&#x27;uniform float sizeAttenuation;&#x27;,
&#x27;&#x27;,
&#x27;varying vec2 vUV;&#x27;,
&#x27;varying vec4 vColor;&#x27;,
&#x27;varying vec3 vPosition;&#x27;,
&#x27;varying float vCounters;&#x27;,
&#x27;&#x27;,
&#x27;vec2 fix( vec4 i, float aspect ) {&#x27;,
&#x27;&#x27;,
&#x27;    vec2 res = i.xy / i.w;&#x27;,
&#x27;    res.x *= aspect;&#x27;,
&#x27;  vCounters = counters;&#x27;,
&#x27;    return res;&#x27;,
&#x27;&#x27;,
&#x27;}&#x27;,
&#x27;&#x27;,
&#x27;void main() {&#x27;,
&#x27;&#x27;,
&#x27;    float aspect = resolution.x / resolution.y;&#x27;,
&#x27;  float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);&#x27;,
&#x27;&#x27;,
&#x27;    vColor = vec4( color, opacity );&#x27;,
&#x27;    vUV = uv;&#x27;,
&#x27;&#x27;,
&#x27;    mat4 m = projectionMatrix * modelViewMatrix;&#x27;,
&#x27;    vec4 finalPosition = m * vec4( position, 1.0 );&#x27;,
&#x27;    vec4 prevPos = m * vec4( previous, 1.0 );&#x27;,
&#x27;    vec4 nextPos = m * vec4( next, 1.0 );&#x27;,
&#x27;&#x27;,
&#x27;    vec2 currentP = fix( finalPosition, aspect );&#x27;,
&#x27;    vec2 prevP = fix( prevPos, aspect );&#x27;,
&#x27;    vec2 nextP = fix( nextPos, aspect );&#x27;,
&#x27;&#x27;,
&#x27;  float pixelWidth = finalPosition.w * pixelWidthRatio;&#x27;,
&#x27;    float w = 1.8 * pixelWidth * lineWidth * width;&#x27;,
&#x27;&#x27;,
&#x27;    if( sizeAttenuation == 1. ) {&#x27;,
&#x27;        w = 1.8 * lineWidth * width;&#x27;,
&#x27;    }&#x27;,
&#x27;&#x27;,
&#x27;    vec2 dir;&#x27;,
&#x27;    if( nextP == currentP ) dir = normalize( currentP - prevP );&#x27;,
&#x27;    else if( prevP == currentP ) dir = normalize( nextP - currentP );&#x27;,
&#x27;    else {&#x27;,
&#x27;        vec2 dir1 = normalize( currentP - prevP );&#x27;,
&#x27;        vec2 dir2 = normalize( nextP - currentP );&#x27;,
&#x27;        dir = normalize( dir1 + dir2 );&#x27;,
&#x27;&#x27;,
&#x27;        vec2 perp = vec2( -dir1.y, dir1.x );&#x27;,
&#x27;        vec2 miter = vec2( -dir.y, dir.x );&#x27;,
&#x27;        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );&#x27;,
&#x27;&#x27;,
&#x27;    }&#x27;,
&#x27;&#x27;,
&#x27;    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;&#x27;,
&#x27;    vec2 normal = vec2( -dir.y, dir.x );&#x27;,
&#x27;    normal.x /= aspect;&#x27;,
&#x27;    normal *= .5 * w;&#x27;,
&#x27;&#x27;,
&#x27;    vec4 offset = vec4( normal * side, 0.0, 1.0 );&#x27;,
&#x27;    finalPosition.xy += offset.xy;&#x27;,
&#x27;&#x27;,
&#x27;  vPosition = ( modelViewMatrix * vec4( position, 1. ) ).xyz;&#x27;,
&#x27;    gl_Position = finalPosition;&#x27;,
&#x27;&#x27;,
&#x27;}&#x27; ];

  var fragmentShaderSource = [
    &#x27;#extension GL_OES_standard_derivatives : enable&#x27;,
&#x27;precision mediump float;&#x27;,
&#x27;&#x27;,
&#x27;uniform sampler2D map;&#x27;,
&#x27;uniform float useMap;&#x27;,
&#x27;uniform float useDash;&#x27;,
&#x27;uniform vec2 dashArray;&#x27;,
&#x27;uniform float visibility;&#x27;,
&#x27;uniform float alphaTest;&#x27;,
&#x27;&#x27;,
&#x27;varying vec2 vUV;&#x27;,
&#x27;varying vec4 vColor;&#x27;,
&#x27;varying vec3 vPosition;&#x27;,
&#x27;varying float vCounters;&#x27;,
&#x27;&#x27;,
&#x27;void main() {&#x27;,
&#x27;&#x27;,
&#x27;    vec4 c = vColor;&#x27;,
&#x27;  if( c.a &lt; alphaTest ) discard;&#x27;,
&#x27;    if( useMap == 1. ) c *= texture2D( map, vUV );&#x27;,
&#x27;  if( useDash == 1. ){&#x27;,
&#x27;    &#x27;,
&#x27;  }&#x27;,
&#x27;    gl_FragColor = c;&#x27;,
&#x27;  gl_FragColor.a *= step(vCounters,visibility);&#x27;,
&#x27;}&#x27; ];

  function check( v, d ) {
    if( v === undefined ) return d;
    return v;
  }

  THREE.Material.call( this );

  parameters = parameters || {};

  this.lineWidth = check( parameters.lineWidth, 1 );
  this.map = check( parameters.map, null );
  this.useMap = check( parameters.useMap, 0 );
  this.color = check( parameters.color, new THREE.Color( 0xffffff ) );
  this.opacity = check( parameters.opacity, 1 );
  this.resolution = check( parameters.resolution, new THREE.Vector2( 1, 1 ) );
  this.sizeAttenuation = check( parameters.sizeAttenuation, 1 );
  this.near = check( parameters.near, 1 );
  this.far = check( parameters.far, 1 );
  this.dashArray = check( parameters.dashArray, [] );
  this.useDash = ( this.dashArray !== [] ) ? 1 : 0;
  this.visibility = check( parameters.visibility, 1 );
  this.alphaTest = check( parameters.alphaTest, 0 );

  var material = new THREE.RawShaderMaterial( {
    uniforms:{
      lineWidth: { type: &#x27;f&#x27;, value: this.lineWidth },
      map: { type: &#x27;t&#x27;, value: this.map },
      useMap: { type: &#x27;f&#x27;, value: this.useMap },
      color: { type: &#x27;c&#x27;, value: this.color },
      opacity: { type: &#x27;f&#x27;, value: this.opacity },
      resolution: { type: &#x27;v2&#x27;, value: this.resolution },
      sizeAttenuation: { type: &#x27;f&#x27;, value: this.sizeAttenuation },
      near: { type: &#x27;f&#x27;, value: this.near },
      far: { type: &#x27;f&#x27;, value: this.far },
      dashArray: { type: &#x27;v2&#x27;, value: new THREE.Vector2( this.dashArray[ 0 ], this.dashArray[ 1 ] ) },
      useDash: { type: &#x27;f&#x27;, value: this.useDash },
      visibility: {type: &#x27;f&#x27;, value: this.visibility},
      alphaTest: {type: &#x27;f&#x27;, value: this.alphaTest}
    },
    vertexShader: vertexShaderSource.join( &#x27;\r\n&#x27; ),
    fragmentShader: fragmentShaderSource.join( &#x27;\r\n&#x27; )
  });

  delete parameters.lineWidth;
  delete parameters.map;
  delete parameters.useMap;
  delete parameters.color;
  delete parameters.opacity;
  delete parameters.resolution;
  delete parameters.sizeAttenuation;
  delete parameters.near;
  delete parameters.far;
  delete parameters.dashArray;
  delete parameters.visibility;
  delete parameters.alphaTest;

  material.type = &#x27;MeshLineMaterial&#x27;;

  material.setValues( parameters );

  return material;

};

MeshLineMaterial.prototype = Object.create( THREE.Material.prototype );
MeshLineMaterial.prototype.constructor = MeshLineMaterial;

MeshLineMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.lineWidth = source.lineWidth;
  this.map = source.map;
  this.useMap = source.useMap;
  this.color.copy( source.color );
  this.opacity = source.opacity;
  this.resolution.copy( source.resolution );
  this.sizeAttenuation = source.sizeAttenuation;
  this.near = source.near;
  this.far = source.far;

  return this;

};

if( typeof exports !== &#x27;undefined&#x27; ) {
  if( typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports ) {
    exports = module.exports = { MeshLine: MeshLine, MeshLineMaterial: MeshLineMaterial };
  }
  exports.MeshLine = MeshLine;
  exports.MeshLineMaterial = MeshLineMaterial;
}
else {
  root.MeshLine = MeshLine;
  root.MeshLineMaterial = MeshLineMaterial;
}

}).call(this);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
